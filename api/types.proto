syntax = "proto3";

package docker.cluster.api;

import "gogoproto/gogo.proto";

// Meta is common to all API objects types.
message Meta {
	string name = 1;
	map<string, string> labels = 2;
}

// Version tracks the last time an object in the store was updated.
message Version {
	uint64 index = 1;
}

// NamespaceSpec defines the user editable fields of a cluster namespace.
message NamespaceSpec {
	Meta meta = 1;
}

// Namespace defines a collection of resources within the cluster. Each
// resource is a member of a namespace. Objects that are a member of a
// namespace inherit the namespace from the request context in which they were
// created. The namespace id (not the name) is added on the object to indicate
// it is a member. Objects may be considered part of a namespace if they are a
// child of an object within a namespace.
//
// Two namespaces always exist. The first is the "default" namespace. The default
// namespace is the namespace used when a namespace is not specified. The other
// is the "system" namespace. The system namespace is used for processes
// critical to running the swarm cluster.
//
// For the purpose of interactions with object, the namespace will be stored in
// the GRPC metadata, under the name "namespace". If the header is not present,
// the default namespace will be used.
message Namespace {
	// ID identifies the namespace.
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version provides the storage revision for the namespace.
	Version Version = 2;

	// Spec provides the user specified details of the namespace.
	NamespaceSpec spec = 3;
}

message Resources {
	// Amount of CPUs (e.g. 2000000000 = 2 CPU cores)
	int64 nano_cpus = 1 [(gogoproto.customname) = "NanoCPUs"];

	// Amount of memory in bytes.
	int64 memory_bytes = 2;
}

message ResourceRequirements {
	Resources limits = 1;
	Resources reservations = 2;
}

message Platform {
	// Architecture (e.g. x86_64)
	string architecture = 1;

	// Operating System (e.g. linux)
	string os = 2 [(gogoproto.customname) = "OS"];
}

message NodeSpec {
	Meta meta = 1 [(gogoproto.nullable) = false];

	enum Availability {
		option (gogoproto.goproto_enum_prefix) = false;

		// Active nodes.
		ACTIVE = 0 [(gogoproto.enumvalue_customname) = "NodeAvailabilityActive"];

		// Paused nodes won't be considered by the scheduler, preventing any
		// further task to run on them.
		PAUSE = 1 [(gogoproto.enumvalue_customname) = "NodeAvailabilityPause"];

		// Drained nodes are paused and any task already running on them will
		// be evicted.
		DRAIN = 2 [(gogoproto.enumvalue_customname) = "NodeAvailabilityDrain"];
	}
	Availability availability = 2;
}

message NodeDescription {
	// Hostname of the node as reported by the agent.
	// This is different from spec.meta.name which is user-defined.
	string hostname = 1;

	// Platform of the node.
	Platform platform = 2;

	// Total resources of the node.
	Resources resources = 3;
}

message Node {
	// ID specifies the identity of the node.
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version tracks the last time the node was modified.
	Version version = 2 [(gogoproto.nullable) = false];

	// Spec defines the desired state of the node as specified by the user.
	// The system will honor this and will *never* modify it.
	NodeSpec spec = 3;

	// Description encapsulated the properties of the Node as reported by the
	// agent.
	NodeDescription description = 4;

	// Status provides the current status of the node, as seen by the manager.
	NodeStatus status = 5 [(gogoproto.nullable) = false];
}

message NodeStatus {
	// TODO(aluzzardi) These should be using `gogoproto.enumvalue_customname`.
	enum State {
		// Unknown indicates the node state cannot be resolved.
		UNKNOWN = 0;

		// Down indicates the node is down.
		DOWN = 1;

		// Ready indicates the node is ready to accept tasks.
		READY = 2;

		// Disconnected indicates the node is currently trying to find new manager.
		DISCONNECTED = 3;
	}

	State state = 1;
	string message = 2;
}

message ImageSpec {
	// reference is a docker image reference. This can include a rpository, tag
	// or be fully qualified witha digest. The format is specified in the
	// distribution/reference package.
	string reference = 1;
}

message ContainerSpec {
	// Resource requirements for the container.
	ResourceRequirements resources = 1;

	ImageSpec image = 2;

	// Command to run the the container. The first element is a path to the
	// executable and the following elements are treated as arguments.
	//
	// If command is empty, execution will fall back to the image's entrypoint.
	repeated string command = 3;

	// Args specifies arguments provided to the image's entrypoint.
	// Ignored if command is specified.
	repeated string args = 4;

	// Env specifies the environment variables for the container in NAME=VALUE
	// format. These must be compliant with  [IEEE Std
	// 1003.1-2001](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html).
	repeated string env = 5;

	// NetworkAttachmentSpec describes a desired attachment to the named network or
	// a specific network_id.
	message NetworkAttachmentSpec {
		oneof reference {
			string name = 1;
			string network_id = 2 [(gogoproto.customname) = "NetworkID"];
		}
	}

	repeated NetworkAttachmentSpec networks = 6;
}

// TaskSpec defines properties required by the agent for execution.
message TaskSpec {
	oneof runtime {
		ContainerSpec container = 1;
	}
}

// JobSpec defines the properties of a Job. As tasks are created, they gain the
// encapsulated template and any emergent properties from the job
// configuration.
//
// There are two key components to a spec. The first is a "source". A source
// defines runnable content. For the swarm use case, this is a container but we
// may extend it to provide other kinds of runnable targets. The second
// component is the "orchestration". The orchestration defines the strategy
// used to the schedule and run the target with a cluster.
message JobSpec {
	Meta meta = 1 [(gogoproto.nullable) = false];

	message ServiceJob {
		// Instances specifies the number of instances of the service job that
		// should be running.
		int64 instances = 1;
	}

	message BatchJob {
		int64 completions = 1;
		int64 paralellism = 2;
	}

	message GlobalJob {
	}

	message CronJob {
	}

	oneof orchestration {
		ServiceJob service = 2;
		BatchJob batch = 3;
		GlobalJob global = 4;
		CronJob cron = 5;
	}

	// Template defines the base configuration for tasks created for this job.
	TaskSpec template = 6;
}

// TODO(aluzzardi): Move it back into `TaskStatus` because of the naming
// collisions of enums.
//
// TaskState enumerates the states that a task progresses through within an
// agent. States are designed to be monotonically increasing, such that if two
// states are seen by a task, the greater of the new represents the true state.
enum TaskState {
	option (gogoproto.goproto_enum_prefix) = false;
	option (gogoproto.enum_customname) = "TaskState";
	NEW = 0 [(gogoproto.enumvalue_customname)="TaskStateNew"];
	ALLOCATED = 1 [(gogoproto.enumvalue_customname)="TaskStateAllocated"]; // successful allocation of resources that the task needs
	ASSIGNED = 2 [(gogoproto.enumvalue_customname)="TaskStateAssigned"];
	ACCEPTED = 3 [(gogoproto.enumvalue_customname)="TaskStateAccepted"]; // task has been accepted by an agent.
	PREPARING = 4 [(gogoproto.enumvalue_customname)="TaskStatePreparing"];
	READY = 5 [(gogoproto.enumvalue_customname)="TaskStateReady"];
	STARTING = 6 [(gogoproto.enumvalue_customname)="TaskStateStarting"];
	RUNNING = 7 [(gogoproto.enumvalue_customname)="TaskStateRunning"];
	SHUTDOWN = 8 [(gogoproto.enumvalue_customname)="TaskStateShutdown"];
	COMPLETE = 9 [(gogoproto.enumvalue_customname)="TaskStateCompleted"]; // successful completion of task (not error code, just ran)
	FAILED = 10 [(gogoproto.enumvalue_customname)="TaskStateFailed"]; // task execution failed with error
	REJECTED = 11 [(gogoproto.enumvalue_customname)="TaskStateRejected"]; // task could not be executed here.
	FINALIZE = 12 [(gogoproto.enumvalue_customname)="TaskStateFinalize"]; // when task is deallocated from node, waiting on cleanup
	DEAD = 13 [(gogoproto.enumvalue_customname)="TaskStateDead"]; // completely finished, unallocated task.
}

message TaskStatus {
	// State expresses the current state of the task.
	TaskState state = 1;

	// Err is set if the task is in an error state.
	//
	// The following states should report a companion error:
	//
	//	FAILED, REJECTED
	//
	// TODO(stevvooe) Integrate this field with the error interface.
	string err = 2;

	// TODO(stevvooe): Report on runtime statistics.
}

// Task specifies the parameters for implementing a Spec. A task is effectively
// immutable and idempotent. Once it is dispatched to a node, it will not be
// dispatched to another node.
message Task {
	// ID uniquely identifies the task in the cluster.
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version tracks the last time the task was modified.
	Version version = 2 [(gogoproto.nullable) = false];

	// JobID indicates the job under which this task is orchestrated. This
	// should almost always be set.
	//
	// A task is considered a child of a job. Thus, task inherits the namespace
	// from the job.
	string job_id = 3 [(gogoproto.customname) = "JobID"];

	// NodeID indicates the node to which the task is assigned. If this field
	// is empty or not set, the task is unassigned.
	string node_id = 4 [(gogoproto.customname) = "NodeID"];

	// Meta inherits labels from the JobSpec.Meta associated with this task. It
	// may include other labels added by the manager. The name will be a human
	// readable name, calculated based on the JobSpec.Meta.Name field.
	Meta meta = 5 [(gogoproto.nullable) = false];

	// Spec declares the runtime parameters for the task. This is copied out of
	// the job's template field.
	TaskSpec spec = 6;

	TaskStatus status = 7;

	// TODO(stevvooe): Task attachement specifications need to be pushed down
	// into a runtime type. With this change, TaskSpec may actually go away.
	// The distinction here is that we need to understand whether or not the
	// agent receives user data.

	message NetworkAttachment {
		// Network state as a whole becomes part of Task so
		// that it always is available for use in agents so
		// that agents don't have any other dependency during execution.
		Network network = 1;

		// List of IPv4/IPv6 addresses that are assigned to the task
		// as part of getting attached to this network.
		repeated string addresses = 2;
	}

	repeated NetworkAttachment networks = 8;
}

message Job {
	// ID uniquely identifies the job.
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version tracks the last time the job was modified.
	Version version = 2 [(gogoproto.nullable) = false];

	// NamespaceID identifies the namespace to which this job belongs.
	string namespace_id = 3 [(gogoproto.customname) = "NamespaceID"];

	JobSpec spec = 4;
}

// IPAMConfiguration specifies parameters for IP Address Management.
message IPAMConfiguration {
	// TODO(stevvooe): It may make more sense to manage IPAM and network
	// definitions separately. This will allow multiple networks to share IPAM
	// instances. For now, we will follow the conventions of libnetwork and
	// specify this as part of the network specification.

	// AddressFamily specifies the network address family that
	// this IPAMConfiguration belongs to.
	enum AddressFamily {
		UNKNOWN = 0; // satisfy proto3
		IPV4 = 4;
		IPV6 = 6;
	}

	AddressFamily family = 1;

	// Subnet defines a network as a CIDR address (ie network and mask
	// 192.168.0.1/24).
	string subnet = 2;

	// Range defines the portion of the subnet to allocate to tasks. This is
	// defined as a subnet within the primary subnet.
	string range = 3;

	// Gateway address within the subnet.
	string gateway = 4;

	// Reserved is a list of address from the master pool that should *not* be
	// allocated. These addresses may have already been allocated or may be
	// reserved for another allocation manager.
	map<string, string> reserved = 5;
}


// Driver is a generic driver type to be used throughout the API. For now, a
// driver is simply a name and set of options. The field contents depend on the
// target use case and driver application. For example, a network driver may
// have different rules than a volume driver.
message Driver {
	string name = 1;
	map <string, string> options = 2;
}

message IPAMOptions {
	Driver driver = 1;
	repeated IPAMConfiguration configurations = 3;
}

// NetworkSpec specifies user defined network parameters.
message NetworkSpec {
	Meta meta = 1 [(gogoproto.nullable) = false];

	// Driver specific configuration consumed by the network driver.
	Driver driver_configuration = 2;

	// IPv6Enabled enables support for IPv6 on the network.
	bool ipv6_enabled = 3;

	// internal restricts external access to the network. This may be
	// accomplished by disabling the default gateway or through other means.
	bool internal = 4;

	IPAMOptions ipam = 5 [(gogoproto.customname) = "IPAM"];
}

message Network {
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version tracks the last time the network was modified.
	Version version = 2 [(gogoproto.nullable) = false];

	// NamespaceID identifies the namespace to which this network belongs.
	string namespace_id = 3 [(gogoproto.customname) = "NamespaceID"];

	NetworkSpec spec = 4;

	// Driver specific operational state provided by the network driver.
	Driver driver_state = 5;

	// Runtime state of IPAM options. This may not reflect the
	// ipam options from NetworkSpec.
	IPAMOptions ipam = 6 [(gogoproto.customname) = "IPAM"];
}

// VolumeSpec defines the properties of a Volume.
message VolumeSpec {
	Meta meta = 1 [(gogoproto.nullable) = false];

	// Driver specific configuration consumed by the Volume driver.
	Driver driver_configuration = 2;
}

message Volume {
	string id = 1 [(gogoproto.customname) = "ID"];

	// Version tracks the last time the volume was modified.
	Version version = 2 [(gogoproto.nullable) = false];
	
	// NamespaceID identifies the namespace to which this volume belongs.
	string namespace_id = 3 [(gogoproto.customname) = "NamespaceID"];

	VolumeSpec spec = 4;

	// Driver specific operational state provided by the Volume driver.
	Driver driver_state = 5;
}

// WeightedPeer should be used anywhere where we are describing a remote peer
// with a weight.
message WeightedPeer {
	string addr = 1;
	double weight = 2;

	// TODO(stevvooe): We must consolidate peer representation in the API.
}

// Contains one of many protobuf encoded objects to replicate
// over the raft backend with a request ID to track when the
// action is effectively applied
message InternalRaftRequest {
	uint64 id = 1 [(gogoproto.customname) = "ID"];

	repeated StoreAction action = 2;
}

// TODO(stevvooe): Storage actions may belong in another protobuf file. They
// aren't necessarily first-class "types" in the cluster schema.

// StoreActionKind defines the operation to take on the store for the target of
// a storage action.
enum StoreActionKind {
	option (gogoproto.goproto_enum_prefix) = false;
	option (gogoproto.enum_customname) = "StoreActionKind";
	UNKNOWN = 0 [(gogoproto.enumvalue_customname) = "StoreActionKindUnknown"]; // default value, invalid
	CREATE = 1 [(gogoproto.enumvalue_customname) = "StoreActionKindCreate"];
	UPDATE = 2 [(gogoproto.enumvalue_customname) = "StoreActionKindUpdate"];
	REMOVE = 3 [(gogoproto.enumvalue_customname) = "StoreActionKindRemove"];
}

// StoreAction defines a taret and operation to apply on the storage system.
message StoreAction {
	StoreActionKind action = 1;
	oneof target {
		Namespace namespace = 2;
		Node node = 3;
		Job job = 4;
		Task task = 5;
		Network network = 6;
		Volume volume = 7;
	}
}
